[
    {
        "description": "Column Info",
        "sql_code": [
            "SELECT a.table_name, a.column_name AS name, d.column_type AS type, a.comment AS description",
            "FROM duckdb_columns() a JOIN (describe aws_all) d ON d.column_name = a.column_name",
            "WHERE a.table_name = 'aws_all'"
        ],
        "r_code": ""
    },
    {
        "description": "Figure 1: Available Instances",
        "sql_code": [
            "WITH cumulative AS (",
            "    SELECT y.year AS avail_since, f.instance,",
            "        CASE",
            "            WHEN f.processor_model IS NULL THEN 'Unknown'",
            "            WHEN f.processor_model LIKE '%AMD%' THEN 'AMD'",
            "            WHEN f.arch = 'arm64' THEN 'AWS Graviton'",
            "            ELSE 'Intel'",
            "        END AS vendor, f.category,",
            "    FROM aws_all f",
            "    JOIN (SELECT DISTINCT floor(release_year) AS year FROM aws_all) y ON floor(f.release_year) <= y.year",
            ")",
            "SELECT c.avail_since, c.vendor, count(*) cnt",
            "FROM cumulative c",
            "GROUP BY ALL"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "theme_set(theme_bw())",
            "# Vendor distribution by release year",
            "df$vendor <- factor(df$vendor, levels = c('Unknown', 'AWS Graviton', 'AMD', 'Intel'))",
            "output <- ggplot(df, aes(x = avail_since, y = cnt)) +",
            "  scale_fill_manual(values = palette.vendor) +",
            "  scale_x_continuous(expand = expansion(add = c(.2,.2))) +",
            "  scale_y_continuous(expand = expansion(add = c(0, 50))) +",
            "  geom_col(aes(fill = vendor, pattern = vendor)) +",
            "  theme(legend.position = 'top') +",
            "  labs(x = 'Year', y = 'Instance Count', fill = 'CPU Vendor')",
            "plot(output); dev.off(); to_svg()"
        ]
    },
    {
        "description": "Figure 2a: SPECint",
        "sql_code": [
            "WITH experiments AS (SELECT value AS specint, release_year, price_hour, family, instance,",
            "       CASE WHEN processor_model LIKE '%AMD%' THEN 'AMD' WHEN arch = 'arm64' THEN 'Graviton' ELSE 'Intel' END AS Vendor, processor_model",
            "FROM aws_all JOIN (FROM benchmark WHERE benchmark = 'specint_full_peak') USING (instance)",
            "WHERE family != 'm5a' AND family != 'c3')",
            "SELECT a.*, (a.specint/a.price_hour)/(b.specint/b.price_hour) spec_normalized",
            "FROM experiments a, experiments b",
            "WHERE b.instance = 'c4.2xlarge'",
            "ORDER BY (a.specint/a.price_hour) DESC"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "output <- ggplot(df, aes(x = release_year, y = spec_normalized, colour = Vendor, group = Vendor)) +",
            "  labs(x = 'Launch Year', y = 'Multi-threaded Performance relative to c4') +",
            "  scale_color_manual(values = palette.vendor) +",
            "  geom_line() +",
            "  geom_label(aes(label = family)) +",
            "  ggtitle('CPU Performance (multi-threaded SPECint) per $') +",
            "  expand_limits(y=0) +",
            "  theme_bw()",
            "plot(output); dev.off(); to_svg()"
        ]
    },
    {
        "description": "Figure 2b: Umbra",
        "sql_code": [
            "WITH experiments AS (SELECT value AS umbratime, release_year, price_hour, family, instance,",
            "       CASE WHEN processor_model LIKE '%AMD%' THEN 'AMD' WHEN arch = 'arm64' THEN 'Graviton' ELSE 'Intel' END AS Vendor, processor_model",
            "FROM aws_all JOIN (FROM benchmark WHERE benchmark = 'umbra_tpchsf10_geommean_executiontime') USING (instance)",
            "WHERE family != 'm5a' AND family != 'c3')",
            "SELECT a.*, (b.umbratime*b.price_hour)/(a.umbratime*a.price_hour) umbra_normalized",
            "FROM experiments a, experiments b",
            "WHERE b.instance = 'c4.2xlarge'",
            "ORDER BY (a.umbratime/a.price_hour) DESC"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "output <- ggplot(df, aes(x = release_year, y = umbra_normalized, colour = Vendor, group = Vendor)) +",
            "  labs(x = 'Launch Year', y = 'Multi-threaded Performance relative to c4') +",
            "  scale_color_manual(values = palette.vendor) +",
            "  geom_line() +",
            "  geom_label(aes(label = family)) +",
            "  ggtitle('CPU Performance (multi-threaded Umbra) per $') +",
            "  expand_limits(y=0) +",
            "  theme_bw()",
            "plot(output); dev.off(); to_svg()"
        ]
    },
    {
        "description": "Figure 2c: Leanstore",
        "sql_code": [
            "WITH experiments AS (SELECT value AS txnpersec, release_year, price_hour, family, instance,",
            "       CASE WHEN processor_model like '%AMD%' THEN 'AMD' when arch = 'arm64' THEN 'Graviton' ELSE 'Intel' END AS Vendor, processor_model",
            "FROM aws_all join (FROM benchmark WHERE benchmark = 'leanstore_tpcc_mean_txnpersec') USING (instance)",
            "WHERE family != 'm5a' AND family != 'c3')",
            "SELECT a.*, (a.txnpersec/a.price_hour)/(b.txnpersec/b.price_hour) leanstore_normalized",
            "FROM experiments a, experiments b",
            "WHERE b.instance = 'c4.2xlarge'",
            "ORDER BY (a.txnpersec/a.price_hour) DESC"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "output <- ggplot(df, aes(x = release_year, y = leanstore_normalized, colour = Vendor, group = Vendor)) +",
            "  labs(x = 'Launch Year', y = 'Multi-threaded Performance relative to c4') +",
            "  scale_color_manual(values = palette.vendor) +",
            "  geom_line() +",
            "  geom_label(aes(label = family)) +",
            "  ggtitle('CPU Performance (multi-threaded Leanstore) per $') +",
            "  expand_limits(y=0) +",
            "  theme_bw()",
            "plot(output); dev.off(); to_svg()"
        ]
    },
    {
        "description": "Figure 3: Memory Capacity",
        "sql_code": [
            "SELECT * FROM aws_family "
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "palette.instance_category <- make.palette(c(",
            "  'General purpose' = 'orange',",
            "  'Compute optimized' = 'dark-blue',",
            "  'Memory optimized' = 'purple',",
            "  'Storage optimized' = 'light-blue',",
            " 'Other' = 'grey'))",
            "",
            "### current query result is in 'df'",
            "output <- ggplot(df, aes(x = release_year, y = ram_gib/price_hour, label=family, color=category)) +",
            "    geom_text() +",
            "    scale_color_manual(values = palette.instance_category) +",
            "    scale_y_continuous('DRAM Capacity (GiB-hour/$)') +",
            "    xlab('Launch Year') +",
            "    ggtitle('RAM capacity trend') +",
            "    expand_limits(y=0) +",
            "    theme_bw()",
            "",
            "plot(output); dev.off(); to_svg() # output to the html page"
        ]
    },
    {
        "description": "Figure 4: Network Bandwidth",
        "sql_code": [
            "SELECT *, (case when family like '%n' THEN TRUE ELSE FALSE END) is_network_optimized",
            "FROM aws_family",
            "WHERE family IN ('c4', 'c5', 'c6g', 'c6a', 'c7g', 'c7i', 'c8g') OR family LIKE 'c%n'"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "",
            "output <- ggplot(df, aes(x=release_year, y=(3600 * net_gbitps/1000 / 8)/price_hour,",
            "                color=is_network_optimized,",
            "                label=paste(family, '\\n', net_gbitps, 'Gbit/s'))) +",
            "    labs(x = 'Launch Year', y = 'Network Bandwidth (TB/$)') +",
            "    geom_text() +",
            "    scale_color_manual(values = make.palette(c('TRUE' = 'dark-green', 'FALSE' = 'black'))) +",
            "    geom_point(color='grey') +",
            "    ggtitle('Network bandwidth trend') +",
            "    expand_limits(y=0) +",
            "    theme_bw()",
            "",
            "plot(output); dev.off(); to_svg() # output to html page"
        ]
    },
    {
        "description": "Figure 5: Memory Bandwidth",
        "sql_code": [
            "WITH membw(processor_model, memorybw) AS (values",
            "    ('Intel Xeon E5-2666 v3 (Haswell)', 93),",
            "    ('Intel Xeon Scalable (Sapphire Rapids)', 201),",
            "    ('Intel Xeon Scalable (Granite Rapids)', 492),",
            "    ('AMD EPYC 7R13 Processor', 175),",
            "    ('AMD EPYC 9R14 Processor', 461),",
            "    ('AWS Graviton2 Processor', 156),",
            "    ('Intel Xeon Platinum 8124M', 99),",
            "    ('Intel Xeon 8375C (Ice Lake)', 158),",
            "    ('AMD EPYC 7R32', 113),",
            "    ('AWS Graviton3 Processor', 262),",
            "    ('AWS Graviton4 Processor', 455)",
            ")",
            "SELECT a.release_year, a.instance, a.family, b.memorybw, round((3600 * b.memorybw/1024)/price_hour) membw_tb_per_dollar",
            "FROM aws_family a",
            "JOIN membw b USING(processor_model)",
            "WHERE a.family IN ('c4', 'c5', 'c6i', 'c7i', 'c8i', 'c5a', 'c6a', 'c7a', 'c6g', 'c7g', 'c8g')"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "",
            "### current query result is in 'df'",
            "output <- ggplot(df, aes(x=release_year, y=membw_tb_per_dollar, label=instance)) +",
            "    geom_point() +",
            "    geom_text(nudge_y=10) +",
            "    expand_limits(y=0)+",
            "    labs(x = 'Launch Year', y = 'Memory Bandwidth (TiB/$)') +",
            "    theme_bw()",
            "",
            "plot(output); dev.off(); to_svg() # output to the html page"        ]
    },
    {
        "description": "Figure 6: SSD Capacity",
        "sql_code": [
            "SELECT family, category, release_year, storage_gb, price_hour",
            "FROM aws_family",
            "WHERE storage_gb > 0 AND storage_is_ssd AND storage_is_nvme"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "",
            "output <- ggplot(df, aes(x = release_year, y = storage_gb/1000/price_hour)) +",
            "    labs(x = 'Launch Year', y = 'NVMe SSD Capacity (TB-hour/$)') +",
            "    geom_point() +",
            "    geom_text(aes(label = family), nudge_y=.2) +",
            "    expand_limits(x=c(2015, 2025.5)) +",
            "    theme_bw()",
            "",
            "plot(output); dev.off(); to_svg() # output to html page"
         ]
    },
    {
        "description": "Figure 7: SSD Bandwidth",
        "sql_code": [
            "SELECT family, release_year, round(storage_read_iops/storage_count, 2) ssd_bw_per_device, 'cloud' source",
            "FROM aws_family",
            "WHERE storage_read_iops > 0 AND storage_count > 0 AND storage_is_ssd",
            "UNION",
            "-- manually define comparable on-prem hardware",
            "SELECT *",
            "FROM VALUES",
            "('Samsung PM983 (PCIe 3)', 2018, 540000, 'On-Premises'),",
            "('Samsung PM1733 (PCIe 4)', 2020, 1500000, 'On-Premises'),",
            "('Kioxia CM7-R (PCIe 5)', 2023, 2700000, 'On-Premises') AS ssds(family, release_year, ssd_bw_per_device, source)"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "",
            "output <- ggplot(df, aes(x=release_year, y=ssd_bw_per_device/1e6, label = family, color = source)) +",
            "    labs(x = 'Launch Year', y = 'MIOPS per SSD Device') +",
            "    scale_color_manual(values = make.palette(c('On-Premises' = 'dark-blue', 'Cloud' = 'carbon'))) +",
            "    geom_point() +",
            "    geom_text(nudge_y=.1) +",
            "    expand_limits(x=c(2015, 2025.5)) +",
            "    theme_bw()",
            "",
            "plot(output); dev.off(); to_svg() # output to html page"
         ]
    },
    {
        "description": "Figure 8: Accelerator FLOPs",
        "sql_code": [
            "-- fall back to prices from other regions or capacity reservation",
            "WITH alt_prices(instance, price_hour) AS (",
            "  VALUES",
            "    ('p5.48xlarge', 55.04),",
            "    ('p6-b200.48xlarge', 113.933),",
            "    ('trn2.48xlarge', 35.0),",
            "    ('p5e.48xlarge', 34.608)",
            "),",
            "accelerators_types(awsname, fp32) AS (",
            "  VALUES",
            "    ('Inferentia', 0.0),",
            "    ('Inferentia2', 47.5),",
            "    ('Trainium', 47.5),",
            "    ('Trainium2', 181),",
            "    ('AMD Radeon Pro V520', 7.4),",
            "    ('NVIDIA L40S', 91.6),",
            "    ('NVIDIA L4', 30.3),",
            "    ('NVIDIA T4', 8.1),",
            "    ('NVIDIA T4g', 8.1),",
            "    ('NVIDIA A10G', 31.2),",
            "    ('NVIDIA H100', 67.0),",
            "    ('NVIDIA H200', 67.0),",
            "    ('NVIDIA V100', 15.7),",
            "    ('NVIDIA B200', 75.0)",
            "),",
            "top_two_per_family AS (",
            "  SELECT *",
            "  FROM (",
            "    SELECT *,",
            "           row_number() OVER (PARTITION BY family ORDER BY vcpus DESC) AS r",
            "    FROM aws_all",
            "  ) t",
            "  WHERE r IN (1,2)",
            "),",
            "one AS (",
            "  SELECT t.*,",
            "         coalesce(NULLIF(t.price_hour,0), ap.price_hour, 35.0) AS eff_price_hour",
            "  FROM top_two_per_family t",
            "  LEFT JOIN alt_prices ap ON t.instance = ap.instance",
            "  WHERE r = 1",
            "),",
            "two AS (",
            "  SELECT t.*,",
            "         coalesce(NULLIF(t.price_hour,0), ap.price_hour, 35.0) AS eff_price_hour",
            "  FROM top_two_per_family t",
            "  LEFT JOIN alt_prices ap ON t.instance = ap.instance",
            "  WHERE r = 2",
            "),",
            "-- choose instance per family using patched (effective) price_hour",
            "chosen_instances AS (",
            "  SELECT CASE",
            "           WHEN two.instance IS NULL THEN one.instance",
            "           WHEN (two.net_gbitps / two.eff_price_hour)",
            "                / (one.net_gbitps / one.eff_price_hour) > 1.1",
            "             THEN two.instance",
            "           ELSE one.instance",
            "         END AS instance",
            "  FROM one",
            "  LEFT JOIN two USING (family)",
            ")",
            "SELECT",
            "  a.release_year,",
            "  a.family,",
            "  a.category,",
            "  a.accelerators,",
            "  a.accelerator_model,",
            "  at.fp32,",
            "  (a.accelerators * at.fp32 * 3600)",
            "    / coalesce(NULLIF(a.price_hour,0), ap_main.price_hour) / 1000 AS tfpd,",
            "  CASE WHEN a.category LIKE '%GPU%' THEN 'GPU' ELSE 'ASIC' END AS acc_type",
            "FROM (",
            "  SELECT * FROM aws_all",
            "  JOIN chosen_instances USING (instance)",
            ") a",
            "LEFT JOIN alt_prices ap_main ON a.instance = ap_main.instance",
            "JOIN accelerators_types at ON a.accelerator_model = at.awsname",
            "WHERE a.accelerators > 0 AND at.fp32 > 0;"
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "",
            "output <- ggplot(df, aes(x=release_year, y=tfpd, label=family, color=acc_type)) +",
            "    geom_point() +",
            "    geom_text(size=6, show.legend = FALSE, max.overlaps = 20) +",
            "    labs(x = 'Launch Year', y = 'FP32 Operations (PFLOPs/$)') +",
            "    scale_x_continuous(limits = c(2015, 2025.5)) +",
            "    expand_limits(y=0) +",
            "    theme_bw()",
            "",
            "plot(output); dev.off(); to_svg() # output to html page"
         ]
    },
    {
        "description": "Figure 9: Demonstration",
        "sql_code": [
            "SELECT instance, family, arch,",
            "       round(storage_gb/price_hour, 2) storage_gbpd,",
            "       (4096. * 8 * storage_read_iops)/1e9 ssd_gbitps,",
            "       round(LEAST(net_gbitps, ssd_gbitps)/price_hour, 2) eff_bw",
            "FROM aws_family",
            "WHERE storage_gb > 0 AND storage_read_iops > 0 AND storage_is_ssd AND storage_is_nvme"  
        ],
        "r_code": [
            "to_svg <- svgstring(width = output.width.inch, height = output.height.inch, scaling = 1)",
            "lbl_instances <- c('i8ge', 'is4gen', 'c7gd', 'c6id', 'm5dn', 'r5dn', 'c6gd', 'i4i', 'i4g', 'i3en', 'i3', 'im4gen', 'i7ie', 'x2idn', 'r5ad', 'm7gd', 'i8g')",
            "lbls <- df[df$family %in% lbl_instances, ]",
            "output <- ggplot(df, aes(x=storage_gbpd, y=eff_bw, label=family, color=arch)) +",
            "    scale_color_manual(values = make.palette(c('Unknown' = 'grey', 'arm64' = 'yellow', 'x86_64' = 'dark-blue'))) +",
            "    ggtitle('Instance SSDs: Capacity/$ vs Effective Bandwidth/$') +",
            "    geom_point() +",
            "    geom_text(data=lbls, nudge_y=.3, size=4) +",
            "    labs(x='Storage Capacity [GB-hour/$]', y='Effective Bandwidth [Gbits-hour/$]') +",
            "    theme_bw()",
            "",
            "plot(output); dev.off(); to_svg() # output to html page"
         ]
    }
]
